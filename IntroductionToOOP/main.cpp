#include<iostream>
#include<math.h>
using namespace std;
using std::cin;
using std::cout;
using std::endl;

class Point //создание структуры или класса
{
	double x;
	double y;
public:
	double get_x()const
	{
		return x;
	}
	double get_y()const
	{
		return y;
	}
	void set_x(double x)
	{
		this->x = x;
	}
	void set_y(double y)
	{
		this->y = y;
	}
	double distance(const Point& B)const
	{
		return sqrt(pow((this->x - B.x), 2) + pow((B.y - this->y), 2));
	}

	//									Constructors:
	//Point()
	//{
	//	x = y = double();//В обе координаты ложим значение по умолчанию для double
	//	cout << "DefaultConstructor:\t" << this << endl;
	//}
	/*Point(double x)
	{
		this->x = x;
		this->y = 0;
		cout << "SingleArgumentConstructor:" << this << endl;
	}*/
	Point(double x = 0, double y = 0)
	{
		this->x = x;
		this->y = y;
		cout << "Constructor:\t" << this << endl;
	}
	Point(const Point& other)
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyConstructor:" << this << endl;
	}
	~Point()
	{
		cout << "Destructor:\t" << this << endl;
	}

	//									Operators:
	Point operator=(const Point& other)
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyAssigment:\t" << this << endl;
		return *this;
	}

	//									Methods:
	void print()const
	{
		cout << "X = " << x << "\tY = " << y << endl;
	}
};

double distance(const Point& A, const Point& B)
{
	return sqrt(pow((A.get_x() - B.get_x()), 2) + pow((B.get_y() - A.get_y()), 2));
}

//#define STRUCT_POINT
//#define CONSTRUCTORS_CHECK
//#define DZ

void main()
{
	setlocale(LC_ALL, "");

#ifdef STRUCT_POINT
	Point A;//Объявление переменной 'А' типа 'Point'
//Создание объекта 'А' структуры 'Point'
	A.x = 2;
	A.y = 3;
	cout << A.x << "\t" << A.y << endl;
	Point* pA = &A;//Создаем или обявляем указатель на поинт
	cout << pA->x << "\t" << pA->y << endl;
#endif // STRUCT_POINT

#ifdef CONSTRUCTORS_CHECK
	Point A;		//Default constructor
	//A.set_x(2);
	//A.set_y(3);
	cout << A.get_x() << "\t" << A.get_y() << endl;
	Point B = 5;	//Single-argument constructor
	B.print();

	Point C(7);		//Single-argument constructor
	C.print();

	Point D(4, 5);	//
	D.print();

	Point E = D;	//Copy Constructor
	E.print();

	Point F;		//Default constructor
	F = E;			//Copy assignment
	F.print();

#endif // CONSTRUCTORS_CHECK

	int a, b, c;
	a = b = c = 0;
	Point A, B, C;
	cout << "\n---------------------------------------------\n";
	A = B = C = Point(2,3);
	cout << "\n---------------------------------------------\n";

#ifdef DZ
	int x;
	int y;
	Point A;
	Point B;
	cout << "Введите координаты точки A: "; cin >> x; cin >> y;
	A.set_x(x);
	A.set_y(y);
	cout << "Введите координаты точки Б: "; cin >> x; cin >> y;
	B.set_x(x);
	B.set_y(y);
	cout << "Растояние до точки A от заданной точки: " << A.distance(B) << endl;
	cout << "Растояние между точками А и Б: " << distance(A, B) << endl;
#endif // DZ


}

/*
Объэктно орентированое программирование на языке С++

Введение в ООП
ООП(Объэктно орентированое программирование) - это подход при котором программа состоит из объэктов и взаимодействие между этими объэктами.
Объэкт - это некая сущность которая существует в пространстве и времени (в реальном мире нам окружают объэкты компьютер, чашка, машина это всё объэкты люди и сами являються объэктами и могут взаимодействовать с другими людьми или с другими объэктами мы перечмслели осазяемые объэкты которые можно увидеть услышать потрогать и так далее но есть и не осязфемые такие как звук воздух ветер).
Все выше перечисленые объэкты находяться объективная существует также субъективная реальность в ней есть так же объэкты.
ООП позволяет объекты объективной и субъективной реальности перенести в виртуальную реальность
Объекты принято класифицировать тоесть каждый объект относиться какомуто классу или является экземпляром какого то класа
Класс - это множество объектов с одинаковым набором свойств или характеристик а так же с одинаковым поведением.
Каждый объект можно охарактеризовать(описать или определить какой это объект) и на самом деле существует множество объектов которых можно одинаково охарактеризовать и их относять к одному классу или являються экземплярами одного и того же класса
Класс это синтаксическая конструкция позволяющая описовать объекты.
Структура - это синтаксическая конструкция позволяющия описовать объекты.
Классы и структуры состоят из полей(членов) - бывают двух видов переменные и методы
class/structur

Data
переменные члены класса(member variables).
характерезуют объекты и описывают их состояние
----------------------------
class CAR
(характеристики автомобиля)
engine_power:  unsigned int;
engine_volume: double;
transmission:  bool;
tank:	       unsigned int;
fuel_type:     string;
color:         Color;
case:          Case;
max_speed      unsigned int;
-----------------------------
(Состояние автомобиля)
engine_started:bool;
speed:         int;
fuel_level     double;
-----------------------------

Methods
Определяют поведение объектов и взаимодействие их с другими объектами(member functions)
----------------------
(Поведение автомобиля)
start_engine():void;
stop_engine(): void;
fill():        void;
gas():         void;
break()        void;
turn_left()    void;
turn_right()   void;
----------------------

Метод - это функция внутри класса
Метод может быть вызван только для какого-то объекта

Объекты класса и структур являються самыми обычными переменными как и переменные они занимают память когда-то создаються и когда-то удаляються
Следовательно классы и структуры являються типами данных Ранее мы работали с примитивными типами данных(int,char,double) а классы и структкры являються пользовательскими типами данных тоесть создавая структуру или класс мы создаем новый тип данных


ОБРАЩЕНИЕ К ПОЛЯМ ОБЪЕКТА
Для обращения к полям объектов используються оператор
.  - Оператор прямого доступа(Point operator) используеться для доступа к полям объекта по именни объекта
-> - Оператор косвенного доступа(Arrow operator) используется для доступа к полям объекта по адресу объекта
Делло в том что имя объекта не всегда возможно узнать но гораздо чаще можно узнать адресс объекта


ОСНОВНЫЕ КОНЦЕПЦИИ ООП
Объекто орентированое программирование базируеться на трё основных концепциях это инкапсуляция, наследование и полиморфизм
1. Encapsulation;
2. Inheritance;
3. Polymorphism;


ENCAPSULATION(Инкапсуляция)
Инкапсуляция - это сокрытие определённой части класса от внешнего мира под внешним миро подразумеваеться всё что находится за пределами класса
Инкопсуляция реализуеться модификаторами доступа:
get/set - методы:
В языке с++ существуют три метода
1.privat		 - это закрытые поля доступны только в нутри класса или структуры в privat секции в обязательном порядке должны находиться переменные(члены) класса это защищает их от случайно перезаписи
2.public		 - это открытые поля доступны из любого места программы в public секции обычно размещают методы хотя методы могут быть и в privat секцию но переменные никогда не могут быть размещены в public
3.protected		 - это защищенные поля доступны изнутри класса и изнутри дочерних классов
				   Этот модификатор доступа используеться только при наследовании
Единственым отличием класса от структуры отличаеться тем что в классе все поля закрыты если не указано обратное а в структуре открыты если не указано обратное


GET/SET МЕТОДЫ
get/set методы открывают доступ к закрытым переменным в классе
get(взять, получить) - открывают доступ на чтение позволяют получить значение закрытой переменной
set(задать, установить) - открывают доступ к закрытым переменным на запись
set методы также обеспечивают фильтрацию данных что предотращает запись некоретных значенний в переменные члены класса
у каждой переменной в классе должен бить свой get и свой set метод тоесть get/set методов в классе должно быть ровно столько сколько и переменных


Инкопсуляция защищает объекты от случайного изменения а также от записи в них некоректных значений блогадоря инкопсуляции в розетке не может быть 1000вольт а катёнак весит 5 кила тон потомучто такие значения будут отфильтрованы set методом


Get методы должны быть константами
константным называется метод который не изменяет объект для которого вызываеться
для констатного объекта могут быдь вызваны только константные методы
this - это указатель на объект для которого вызываеться метод изнутри метода невозможно узнать имя объекта для которого он вызываеться но всегда можно узнать адресс объекта при помощи this
Наследование и полиморфизм будут рассмотренны отдельной темой пока они не актуальны сейчас самое главное это инкапсуляция

Конструкторы
В любом классе обязательно должны быть некоторые специальные методы некоторые из них могут добавляться в класс не явно компилятором обязательным методом класса относяться
1.Constructor - это метод который создает объект а именно выделяет память под объект инициалезирует его поля при его создании
2.Destructor - это метод который уничтожает объект по завершении его времени жизни. Время жизни объекта заканчивается при выходе из области видимости в которой он обявлен это может быть функция, for, if и так далее тоесть любая конструкция с фигурными скобками
3.AssigmentOperator(оператор присвоить)

Конструктор как и любая функция может принимать параметры поэтому конструктор как и любую другую функцию можно перегрузить в классе может быть сколько угодно конструкторов. Каждый из этих конструкторов будет создаваться по разному всависимости от того какой объект мы хотим и как мы хотим его создать
Декструктор никогда не принимает никаких параметров по этому его нельзя перегрузить и именно по этому в класе может быть только один диструктор. Независимо от того каким образом(конструктором) был создан все объекты удаляються одинаково
Конструктор как и диструктор как правило вызывается не явно хотя их можно вызвать и явным образом
Конструкторы бывают
1.с параметрами
2.без параметров
3.по умолчанию - это конструктор который может быть вызван без параметров. Это может быть конструктор не принимающий никаких параметров или же конструктор каждый параметр которого имеет значение по умолчанию
4.конструктор копирования
5.конструктор переноса

по умолчанию - это конструктор который может быть вызван без параметров. Это может быть конструктор не принимающий никаких параметров или же конструктор каждый параметр которого имеет значение по умолчанию
Если в классе нет ни одного конструктора то компилятор сам добавит туда конструктор по умалчанию по скольку без конструктора невозможно создать объект этот не явный конструктор по умалчанию просто выделит память под объект и заполнит его поля мусором
КОНСТРУКТОР И ДИСТРУКТОР ВСЕГДА НАЗЫВАЮТСЯ ТАКЖЕ КАК И КЛАСС НО ПЕРЕД ДИСТРУКТОРОМ ВСЕГДА СТАВИТЬСЯ (~ - TILDA)


Конструктор Копирования - это конструктор который копирует объект а точнее создаваемый объект делает точной копией другого существуещего объекта или выполняет побитовое копирование
Контсруктор копирования всегда принимает константную сылку на объект
Конструктор копирования можно вызвать лишь присоздании объекта его нельзя вызвать для существующего объекта если есть необходимость существующий объект сделать точной копией другого существующего объекта в классе должен быть оператор присваивания
Оператор присваивания делает существующий объект точной копией другого существующего объекта тоесть он делает тоже самое что конструктор копирования но не для создаваемого а для существующего объекта


*/

