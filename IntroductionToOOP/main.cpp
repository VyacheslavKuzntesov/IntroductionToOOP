#include<iostream>
#include<math.h>
using namespace std;
using std::cin;
using std::cout;
using std::endl;

class Point //создание структуры или класса
{
	double x;
	double y;
public:
	double get_x()const
	{
		return x;
	}
	double get_y()const
	{
		return y;
	}
	void set_x(double x)
	{
		this->x = x;
	}
	void set_y(double y)
	{
		this->y = y;
	}
	double distance(const Point& B)const
	{
		return sqrt(pow((this->x - B.x), 2) + pow((this->y - B.y), 2));
	}

	//									Constructors:
	//Point()
	//{
	//	x = y = double();//В обе координаты ложим значение по умолчанию для double
	//	cout << "DefaultConstructor:\t" << this << endl;
	//}
	/*Point(double x)
	{
		this->x = x;
		this->y = 0;
		cout << "SingleArgumentConstructor:" << this << endl;
	}*/
	Point(double x = 0, double y = 0)
	{
		this->x = x;
		this->y = y;
		cout << "Constructor:\t" << this << endl;
	}
	Point(const Point& other)
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyConstructor:" << this << endl;
	}
	~Point()
	{
		cout << "Destructor:\t" << this << endl;
	}

	//									Operators:
	Point& operator=(const Point& other)
	{
		this->x = other.x;
		this->y = other.y;
		cout << "CopyAssigment:\t" << this << endl;
		return *this;
	}

	Point operator+=(const Point& other)
	{
		this->x += other.x;
		this->y += other.y;
		return *this;
	}

	//									Increment/Decrement
	Point operator++() //Prefix increment
	{
		x++;
		y++;
		return *this;
	}

	Point operator++(int) //
	{
		Point old = *this; // Сохраняем старое значения объекта
		x++;
		y++;
		return old;
	}

	Point operator--()
	{
		x--;
		y--;
		return *this;
	}

	//									Methods:
	void print()const
	{
		cout << "X = " << x << "\tY = " << y << endl;
	}
};

double distance(const Point& A, const Point& B)
{
	return sqrt(pow((A.get_x() - B.get_x()), 2) + pow((A.get_y() - B.get_y()), 2));
}

Point operator+(const Point& left, const Point& right)
{
	Point result; // локальный объект, в который будет сохранен результат
	result.set_x(left.get_x() + right.get_x());
	result.set_y(left.get_y() + right.get_y());
	return result;
}

Point operator-(const Point& left, const Point& right)
{
	Point result(left.get_x() - right.get_x(), left.get_y() - right.get_y()); // локальный объект, в который будет сохранен результат
	return result;
}

Point operator*(const Point& left, const Point& right)
{
	return Point(left.get_x() * right.get_x(), left.get_y() * right.get_y());
}

ostream& operator<<(ostream& os, const Point& obj)
{
	os << "X = " << obj.get_x() << "\tY = " << obj.get_y();
	return os;
}

//#define STRUCT_POINT
//#define CONSTRUCTORS_CHECK
//#define DZ
//#define ASSIGMENT_CHECK
//#define DISTAN_CHECK
//#define ARITHMETICAL_OPERATORS_CHECK
#define delimeter cout << "\n---------------------------------------------\n"

void main()
{
	setlocale(LC_ALL, "");

#ifdef STRUCT_POINT
	Point A;//Объявление переменной 'А' типа 'Point'
//Создание объекта 'А' структуры 'Point'
	A.x = 2;
	A.y = 3;
	cout << A.x << "\t" << A.y << endl;
	Point* pA = &A;//Создаем или обявляем указатель на поинт
	cout << pA->x << "\t" << pA->y << endl;
#endif // STRUCT_POINT

#ifdef CONSTRUCTORS_CHECK
	Point A;		//Default constructor
	//A.set_x(2);
	//A.set_y(3);
	cout << A.get_x() << "\t" << A.get_y() << endl;
	Point B = 5;	//Single-argument constructor
	B.print();

	Point C(7);		//Single-argument constructor
	C.print();

	Point D(4, 5);	//
	D.print();

	Point E = D;	//Copy Constructor
	E.print();

	Point F;		//Default constructor
	F = E;			//Copy assignment
	F.print();

#endif // CONSTRUCTORS_CHECK

#ifdef ASSIGMENT_CHECK
	int a, b, c;
	a = b = c = 0;
	Point A, B, C;
	delimeter;
	A = B = C = Point(2, 3);
	delimeter;
	A.print();
	B.print();
	C.print();

#endif // ASSIGMENT_CHECK

#ifdef DISTAN_CHECK
	A = Point(2, 3);
	B = Point(3, 4);
	delimeter;
	cout << "Растояние от точки А до точки B: " << A.distance(B) << endl;
	delimeter;
	cout << "Растояние от точки B до точки A: " << B.distance(A) << endl;
	delimeter;
	cout << "Растояние от точки A до точки B: " << distance(A, B) << endl;
	delimeter;
	cout << "Растояние от точки B до точки A: " << distance(B, A) << endl;
	delimeter;
#endif // DISTAN_CHECK

#ifdef DZ
	int x;
	int y;
	Point A;
	Point B;
	cout << "Введите координаты точки A: "; cin >> x; cin >> y;
	A.set_x(x);
	A.set_y(y);
	cout << "Введите координаты точки Б: "; cin >> x; cin >> y;
	B.set_x(x);
	B.set_y(y);
	cout << "Растояние до точки A от заданной точки: " << A.distance(B) << endl;
	cout << "Растояние между точками А и Б: " << distance(A, B) << endl;
#endif // DZ

#ifdef  ARITHMETICAL_OPERATORS_CHECK
	Point A(2, 3);
	Point B(3, 4);
	Point C = A + B;
	C.print();
	Point D = A - B;
	D.print();
	(A * B).print();
#endif //  ARITHMETICAL_OPERATORS_CHECK

	Point A(2, 3);
	Point B(3, 4);
	A += B;
	A.print();
	B = A++;
	/*for (Point i = 0; i.get_x() < 10; i++)
	{
		i.print();
	}*/
	cout << A << endl;
	cout << B << endl;
}

/*
Объэктно орентированое программирование на языке С++

Введение в ООП
ООП(Объэктно орентированое программирование) - это подход при котором программа состоит из объэктов и взаимодействие между этими объэктами.
Объэкт - это некая сущность которая существует в пространстве и времени (в реальном мире нам окружают объэкты компьютер, чашка, машина это всё объэкты люди и сами являються объэктами и могут взаимодействовать с другими людьми или с другими объэктами мы перечмслели осазяемые объэкты которые можно увидеть услышать потрогать и так далее но есть и не осязфемые такие как звук воздух ветер).
Все выше перечисленые объэкты находяться объективная существует также субъективная реальность в ней есть так же объэкты.
ООП позволяет объекты объективной и субъективной реальности перенести в виртуальную реальность
Объекты принято класифицировать тоесть каждый объект относиться какомуто классу или является экземпляром какого то класа
Класс - это множество объектов с одинаковым набором свойств или характеристик а так же с одинаковым поведением.
Каждый объект можно охарактеризовать(описать или определить какой это объект) и на самом деле существует множество объектов которых можно одинаково охарактеризовать и их относять к одному классу или являються экземплярами одного и того же класса
Класс это синтаксическая конструкция позволяющая описовать объекты.
Структура - это синтаксическая конструкция позволяющия описовать объекты.
Классы и структуры состоят из полей(членов) - бывают двух видов переменные и методы
class/structur

Data
переменные члены класса(member variables).
характерезуют объекты и описывают их состояние
----------------------------
class CAR
(характеристики автомобиля)
engine_power:  unsigned int;
engine_volume: double;
transmission:  bool;
tank:	       unsigned int;
fuel_type:     string;
color:         Color;
case:          Case;
max_speed      unsigned int;
-----------------------------
(Состояние автомобиля)
engine_started:bool;
speed:         int;
fuel_level     double;
-----------------------------

Methods
Определяют поведение объектов и взаимодействие их с другими объектами(member functions)
----------------------
(Поведение автомобиля)
start_engine():void;
stop_engine(): void;
fill():        void;
gas():         void;
break()        void;
turn_left()    void;
turn_right()   void;
----------------------

Метод - это функция внутри класса
Метод может быть вызван только для какого-то объекта

Объекты класса и структур являються самыми обычными переменными как и переменные они занимают память когда-то создаються и когда-то удаляються
Следовательно классы и структуры являються типами данных Ранее мы работали с примитивными типами данных(int,char,double) а классы и структкры являються пользовательскими типами данных тоесть создавая структуру или класс мы создаем новый тип данных


ОБРАЩЕНИЕ К ПОЛЯМ ОБЪЕКТА
Для обращения к полям объектов используються оператор
.  - Оператор прямого доступа(Point operator) используеться для доступа к полям объекта по именни объекта
-> - Оператор косвенного доступа(Arrow operator) используется для доступа к полям объекта по адресу объекта
Делло в том что имя объекта не всегда возможно узнать но гораздо чаще можно узнать адресс объекта


ОСНОВНЫЕ КОНЦЕПЦИИ ООП
Объекто орентированое программирование базируеться на трё основных концепциях это инкапсуляция, наследование и полиморфизм
1. Encapsulation;
2. Inheritance;
3. Polymorphism;


ENCAPSULATION(Инкапсуляция)
Инкапсуляция - это сокрытие определённой части класса от внешнего мира под внешним миро подразумеваеться всё что находится за пределами класса
Инкопсуляция реализуеться модификаторами доступа:
get/set - методы:
В языке с++ существуют три метода
1.privat		 - это закрытые поля доступны только в нутри класса или структуры в privat секции в обязательном порядке должны находиться переменные(члены) класса это защищает их от случайно перезаписи
2.public		 - это открытые поля доступны из любого места программы в public секции обычно размещают методы хотя методы могут быть и в privat секцию но переменные никогда не могут быть размещены в public
3.protected		 - это защищенные поля доступны изнутри класса и изнутри дочерних классов
				   Этот модификатор доступа используеться только при наследовании
Единственым отличием класса от структуры отличаеться тем что в классе все поля закрыты если не указано обратное а в структуре открыты если не указано обратное


GET/SET МЕТОДЫ
get/set методы открывают доступ к закрытым переменным в классе
get(взять, получить) - открывают доступ на чтение позволяют получить значение закрытой переменной
set(задать, установить) - открывают доступ к закрытым переменным на запись
set методы также обеспечивают фильтрацию данных что предотращает запись некоретных значенний в переменные члены класса
у каждой переменной в классе должен бить свой get и свой set метод тоесть get/set методов в классе должно быть ровно столько сколько и переменных


Инкопсуляция защищает объекты от случайного изменения а также от записи в них некоректных значений блогадоря инкопсуляции в розетке не может быть 1000вольт а катёнак весит 5 кила тон потомучто такие значения будут отфильтрованы set методом


Get методы должны быть константами
константным называется метод который не изменяет объект для которого вызываеться
для констатного объекта могут быдь вызваны только константные методы
this - это указатель на объект для которого вызываеться метод изнутри метода невозможно узнать имя объекта для которого он вызываеться но всегда можно узнать адресс объекта при помощи this
Наследование и полиморфизм будут рассмотренны отдельной темой пока они не актуальны сейчас самое главное это инкапсуляция

Конструкторы
В любом классе обязательно должны быть некоторые специальные методы некоторые из них могут добавляться в класс не явно компилятором обязательным методом класса относяться
1.Constructor - это метод который создает объект а именно выделяет память под объект инициалезирует его поля при его создании
2.Destructor - это метод который уничтожает объект по завершении его времени жизни. Время жизни объекта заканчивается при выходе из области видимости в которой он обявлен это может быть функция, for, if и так далее тоесть любая конструкция с фигурными скобками
3.AssigmentOperator(оператор присвоить)

Конструктор как и любая функция может принимать параметры поэтому конструктор как и любую другую функцию можно перегрузить в классе может быть сколько угодно конструкторов. Каждый из этих конструкторов будет создаваться по разному всависимости от того какой объект мы хотим и как мы хотим его создать
Декструктор никогда не принимает никаких параметров по этому его нельзя перегрузить и именно по этому в класе может быть только один диструктор. Независимо от того каким образом(конструктором) был создан все объекты удаляються одинаково
Конструктор как и диструктор как правило вызывается не явно хотя их можно вызвать и явным образом
Конструкторы бывают
1.с параметрами
2.без параметров
3.по умолчанию - это конструктор который может быть вызван без параметров. Это может быть конструктор не принимающий никаких параметров или же конструктор каждый параметр которого имеет значение по умолчанию
4.конструктор копирования
5.конструктор переноса

по умолчанию - это конструктор который может быть вызван без параметров. Это может быть конструктор не принимающий никаких параметров или же конструктор каждый параметр которого имеет значение по умолчанию
Если в классе нет ни одного конструктора то компилятор сам добавит туда конструктор по умалчанию по скольку без конструктора невозможно создать объект этот не явный конструктор по умалчанию просто выделит память под объект и заполнит его поля мусором
КОНСТРУКТОР И ДИСТРУКТОР ВСЕГДА НАЗЫВАЮТСЯ ТАКЖЕ КАК И КЛАСС НО ПЕРЕД ДИСТРУКТОРОМ ВСЕГДА СТАВИТЬСЯ (~ - TILDA)


Конструктор Копирования - это конструктор который копирует объект а точнее создаваемый объект делает точной копией другого существуещего объекта или выполняет побитовое копирование
Контсруктор копирования всегда принимает константную сылку на объект
Конструктор копирования можно вызвать лишь присоздании объекта его нельзя вызвать для существующего объекта если есть необходимость существующий объект сделать точной копией другого существующего объекта в классе должен быть оператор присваивания
Оператор присваивания делает существующий объект точной копией другого существующего объекта тоесть он делает тоже самое что конструктор копирования но не для создаваемого а для существующего объекта

МЫ много говорили о том как функция может принимать параметры но никогда не говорили о том как она может возвращать значения
Значение из функции также можна возвращаться по значению по указателю либо по ссылке.
Локальные переменные объявленные в функции или в методе можно вернуть только по значению при возврате их по ссылке на месте вызова будет мусор по скольку для локальных объектов по завершению функций вызываеться диструктор

Перегрузка операторов
Перегрузка операторов нужна для более удобной работы с объектами что бы над объектами нашего класса можно было выполнять такие же операции как и над обычными переменнами +,-,/ и так далее
Перегнруженные операторы это самые обычные функции иммя которых состоит из ключевого слова operator и знака оператора
------------------------------------------------------------------------------
Правила перегрузки операторов:
1. Перегрузить можно только существующие операторы Нельзя создавать новые операторы например:
	+  - перегружается
	++ - перегружается
	*  - перегружается
	** - не перегружается
2. Не все существующие операторы можна перегрузить
	Не перегружаются:
	?: - тернарный
	:: - Оператор разрешения видимости
	.  - Оператор прямого доступа
	.* - Pointer to class member operator
	#
	##
3. Перегруженные операторы сохраняют приоритет
4. Переопределить поведение операторов над встроенными типами невозможно
------------------------------------------------------------------------------
Операторы можно перегружать как в классе так и за классом если оператор перегружен в классе то он является методом и может быть вызван лишь для кокогото объекта если же оператор перегружен за классом то он являеться обычной функцией.
Если унарный оператор перегружается в классе то он никогда не принимает никаких параметров а его единственным операндом является объект для которого он вызывается и оператор может получить доступ к своему операнду через this.
Если же унарный оператор перегружается за классом то он обязательном порядке будет принимать только один параметр свой операнд.
Если бинарный оператор перегружается в классе то он обязательном порядке принимает один и только один параметр - операнд справа его операндом слева являеться объект для которого он вызывается и книму можно получить доступ через this
Если бинарный оператор перегружается за классом то он обязательном порядке принимает два параметра операнд слева и операнд справа

Некоторые операторы не изменяют свои операнды а некоторые изменяют свои операнды Операторы которые не изменяют свои операнды лучше перегрузить за классом а те которые изменяют свои операнды удобней перегружать внутри класса что бы иметь прямой доступ к объектам
Арефметические операторы лучше перегружать за классом
Составные присваевания лучше перегружать в классе
*/

